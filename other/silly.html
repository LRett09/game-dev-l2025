<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Reliable Task Manager Demo</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-50">
<div id="root"></div>
<script type="text/babel">
import React, { useEffect, useMemo, useRef, useState } from "react";

// Single-file React component. Uses Tailwind utility classes for styling.
// Drop this file into a Create React App / Vite React + Tailwind project and render <TaskManager />.
// Features:
// - Tasks with title, description, tags, priority, due date
// - Subtasks
// - Drag & drop reordering (HTML5 drag/drop)
// - Persist to localStorage
// - Search, filter, sort
// - Import / Export JSON
// - Inline edit, mark complete, clear completed

const STORAGE_KEY = "task_manager_v1";

function uid(prefix = "id") {
  return `${prefix}_${Math.random().toString(36).slice(2, 9)}`;
}

function nowISO() {
  return new Date().toISOString();
}

function readStorage() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (e) {
    console.error("Failed reading storage", e);
    return null;
  }
}

function writeStorage(data) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  } catch (e) {
    console.error("Failed writing storage", e);
  }
}

const DEFAULTS = {
  tasks: [],
  createdAt: nowISO(),
};

export default function TaskManager() {
  const [state, setState] = useState(() => readStorage() || DEFAULTS);
  const [query, setQuery] = useState("");
  const [filter, setFilter] = useState("all"); // all, active, completed
  const [sort, setSort] = useState("manual"); // manual, created, due, priority
  const [form, setForm] = useState({
    title: "",
    description: "",
    tags: "",
    due: "",
    priority: "normal",
  });
  const dragIdRef = useRef(null);

  useEffect(() => {
    writeStorage(state);
  }, [state]);

  // Derived lists
  const tasksFiltered = useMemo(() => {
    const q = query.trim().toLowerCase();
    let list = [...state.tasks];

    if (q) {
      list = list.filter((t) => {
        return (
          t.title.toLowerCase().includes(q) ||
          (t.description || "").toLowerCase().includes(q) ||
          (t.tags || []).join(" ").toLowerCase().includes(q)
        );
      });
    }

    if (filter === "active") list = list.filter((t) => !t.done);
    if (filter === "completed") list = list.filter((t) => t.done);

    switch (sort) {
      case "created":
        list.sort((a, b) => (a.createdAt < b.createdAt ? 1 : -1));
        break;
      case "due":
        list.sort((a, b) => {
          if (!a.due) return 1;
          if (!b.due) return -1;
          return a.due > b.due ? 1 : -1;
        });
        break;
      case "priority":
        const weight = (p) => (p === "high" ? 0 : p === "normal" ? 1 : 2);
        list.sort((a, b) => weight(a.priority) - weight(b.priority));
        break;
      case "manual":
      default:
        // respect order array
        break;
    }

    return list;
  }, [state.tasks, query, filter, sort]);

  function addTask(e) {
    e && e.preventDefault();
    const title = (form.title || "").trim();
    if (!title) return;
    const newTask = {
      id: uid("task"),
      title,
      description: form.description || "",
      tags: (form.tags || "").split(",").map((t) => t.trim()).filter(Boolean),
      createdAt: nowISO(),
      due: form.due || null,
      priority: form.priority || "normal",
      done: false,
      subtasks: [],
    };
    setState((s) => ({ ...s, tasks: [newTask, ...s.tasks] }));
    setForm({ title: "", description: "", tags: "", due: "", priority: "normal" });
  }

  function toggleDone(id) {
    setState((s) => ({
      ...s,
      tasks: s.tasks.map((t) => (t.id === id ? { ...t, done: !t.done } : t)),
    }));
  }

  function updateTask(id, patch) {
    setState((s) => ({ ...s, tasks: s.tasks.map((t) => (t.id === id ? { ...t, ...patch } : t)) }));
  }

  function removeTask(id) {
    setState((s) => ({ ...s, tasks: s.tasks.filter((t) => t.id !== id) }));
  }

  function clearCompleted() {
    setState((s) => ({ ...s, tasks: s.tasks.filter((t) => !t.done) }));
  }

  function exportJSON() {
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `tasks_export_${new Date().toISOString()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const parsed = JSON.parse(ev.target.result);
        if (!parsed.tasks) throw new Error("Invalid file");
        setState(parsed);
      } catch (e) {
        alert("Failed to import: " + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Drag & drop handlers for reordering
  function onDragStart(e, id) {
    dragIdRef.current = id;
    e.dataTransfer.effectAllowed = "move";
    try { e.dataTransfer.setData("text/plain", id); } catch (err) {}
  }

  function onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }

  function onDrop(e, overId) {
    e.preventDefault();
    const draggedId = dragIdRef.current || e.dataTransfer.getData("text/plain");
    if (!draggedId) return;
    if (draggedId === overId) return;
    setState((s) => {
      const list = [...s.tasks];
      const fromIdx = list.findIndex((t) => t.id === draggedId);
      const toIdx = list.findIndex((t) => t.id === overId);
      if (fromIdx === -1 || toIdx === -1) return s;
      const [item] = list.splice(fromIdx, 1);
      list.splice(toIdx, 0, item);
      return { ...s, tasks: list };
    });
    dragIdRef.current = null;
  }

  // Subtasks
  function addSubtask(parentId, text) {
    if (!text) return;
    setState((s) => ({
      ...s,
      tasks: s.tasks.map((t) =>
        t.id === parentId
          ? { ...t, subtasks: [{ id: uid("st"), title: text, done: false }, ...t.subtasks] }
          : t
      ),
    }));
  }

  function toggleSubtask(parentId, subId) {
    setState((s) => ({
      ...s,
      tasks: s.tasks.map((t) =>
        t.id === parentId
          ? { ...t, subtasks: t.subtasks.map((st) => (st.id === subId ? { ...st, done: !st.done } : st)) }
          : t
      ),
    }));
  }

  function removeSubtask(parentId, subId) {
    setState((s) => ({
      ...s,
      tasks: s.tasks.map((t) => (t.id === parentId ? { ...t, subtasks: t.subtasks.filter((st) => st.id !== subId) } : t)),
    }));
  }

  // Small helpers
  function countCompleted() {
    return state.tasks.filter((t) => t.done).length;
  }

  function samplePopulate() {
    const sample = {
      tasks: [
        {
          id: uid("task"),
          title: "Plan weekly review",
          description: "Gather notes, review goals, plan next week",
          tags: ["planning", "weekly"],
          createdAt: nowISO(),
          due: null,
          priority: "normal",
          done: false,
          subtasks: [
            { id: uid("st"), title: "Collect notes", done: false },
            { id: uid("st"), title: "Update backlog", done: false },
          ],
        },
        {
          id: uid("task"),
          title: "Pay rent",
          description: "Confirm amount and schedule transfer",
          tags: ["finance"],
          createdAt: nowISO(),
          due: new Date(Date.now() + 3 * 24 * 3600 * 1000).toISOString(),
          priority: "high",
          done: false,
          subtasks: [],
        },
      ],
      createdAt: nowISO(),
    };
    setState(sample);
  }

  return (
    <div className="max-w-4xl mx-auto p-4">
      <header className="mb-4">
        <h1 className="text-2xl font-bold">Reliable Task Manager</h1>
        <p className="text-sm text-gray-600">Designed to be robust and work first try — single file React + Tailwind.</p>
      </header>

      <section className="mb-4 grid grid-cols-1 md:grid-cols-3 gap-3">
        <form className="md:col-span-2 bg-white shadow rounded p-3" onSubmit={addTask}>
          <div className="flex gap-2">
            <input className="flex-1 p-2 border rounded" placeholder="Task title" value={form.title}
              onChange={(e) => setForm((f) => ({ ...f, title: e.target.value }))}
            />
            <select className="p-2 border rounded" value={form.priority}
              onChange={(e) => setForm((f) => ({ ...f, priority: e.target.value }))}
            >
              <option value="high">High</option>
              <option value="normal">Normal</option>
              <option value="low">Low</option>
            </select>
            <button className="px-3 py-2 bg-blue-600 text-white rounded" type="submit">Add</button>
          </div>

          <div className="mt-2 grid grid-cols-1 md:grid-cols-3 gap-2">
            <input className="p-2 border rounded" placeholder="Tags (comma separated)" value={form.tags}
              onChange={(e) => setForm((f) => ({ ...f, tags: e.target.value }))}
            />
            <input className="p-2 border rounded" type="date" value={form.due}
              onChange={(e) => setForm((f) => ({ ...f, due: e.target.value }))}
            />
            <input className="p-2 border rounded" placeholder="Short description" value={form.description}
              onChange={(e) => setForm((f) => ({ ...f, description: e.target.value }))}
            />
          </div>
        </form>

        <aside className="bg-white shadow rounded p-3 flex flex-col gap-2">
          <div className="flex gap-2">
            <input className="flex-1 p-2 border rounded" placeholder="Search" value={query} onChange={(e) => setQuery(e.target.value)} />
            <button className="p-2 border rounded" onClick={() => { setQuery(""); setFilter("all"); setSort("manual"); }}>Reset</button>
          </div>

          <div className="flex gap-2 text-sm">
            <select value={filter} onChange={(e) => setFilter(e.target.value)} className="p-2 border rounded">
              <option value="all">All</option>
              <option value="active">Active</option>
              <option value="completed">Completed</option>
            </select>
            <select value={sort} onChange={(e) => setSort(e.target.value)} className="p-2 border rounded">
              <option value="manual">Manual</option>
              <option value="created">Newest</option>
              <option value="due">Due date</option>
              <option value="priority">Priority</option>
            </select>
          </div>

          <div className="flex gap-2">
            <button className="flex-1 p-2 border rounded" onClick={exportJSON}>Export</button>
            <label className="flex-1 p-2 border rounded text-center cursor-pointer">
              Import
              <input type="file" accept="application/json" onChange={(e) => importJSON(e.target.files?.[0])} className="hidden" />
            </label>
          </div>

          <div className="flex gap-2">
            <button className="flex-1 p-2 border rounded" onClick={() => { if (confirm('Populate with sample tasks? This will overwrite your current list.')) samplePopulate(); }}>Sample</button>
            <button className="flex-1 p-2 border rounded" onClick={() => { if (confirm('Clear completed tasks?')) clearCompleted(); }}>Clear completed</button>
          </div>

          <div className="text-xs text-gray-600">Tasks: {state.tasks.length} • Completed: {countCompleted()}</div>
        </aside>
      </section>

      <main>
        <ul className="space-y-2">
          {tasksFiltered.map((t) => (
            <li key={t.id}
              draggable
              onDragStart={(e) => onDragStart(e, t.id)}
              onDragOver={onDragOver}
              onDrop={(e) => onDrop(e, t.id)}
              className="bg-white p-3 shadow rounded flex flex-col"
            >
              <div className="flex items-start gap-3">
                <input type="checkbox" className="mt-1" checked={t.done} onChange={() => toggleDone(t.id)} />
                <div className="flex-1">
                  <div className="flex justify-between items-start gap-2">
                    <div>
                      <div className={`text-lg font-medium ${t.done ? 'line-through text-gray-500' : ''}`}>{t.title}</div>
                      <div className="text-sm text-gray-600">{t.description}</div>
                    </div>

                    <div className="text-right text-xs">
                      <div className="mb-1">{t.priority}</div>
                      <div className="text-gray-500">{t.due ? new Date(t.due).toLocaleDateString() : '-'}</div>
                    </div>
                  </div>

                  <div className="mt-2 flex flex-wrap gap-2">
                    {t.tags && t.tags.map((tag) => (
                      <span key={tag} className="text-xs border px-2 py-1 rounded">#{tag}</span>
                    ))}
                  </div>

                  <div className="mt-2 flex gap-2 text-sm">
                    <button onClick={() => {
                      const newTitle = prompt('Edit title', t.title);
                      if (newTitle === null) return;
                      updateTask(t.id, { title: newTitle });
                    }} className="p-1 border rounded">Edit</button>

                    <button onClick={() => {
                      const desc = prompt('Edit description', t.description || '');
                      if (desc === null) return;
                      updateTask(t.id, { description: desc });
                    }} className="p-1 border rounded">Edit desc</button>

                    <button onClick={() => { if (confirm('Delete task?')) removeTask(t.id); }} className="p-1 border rounded">Delete</button>
                  </div>

                  {/* Subtasks UI */}
                  <div className="mt-3 border-t pt-2">
                    <SubtaskList task={t} addSubtask={addSubtask} toggleSubtask={toggleSubtask} removeSubtask={removeSubtask} />
                  </div>
                </div>
              </div>
            </li>
          ))}
        </ul>

        {tasksFiltered.length === 0 && (
          <div className="mt-6 text-center text-gray-500">No tasks match your filters.</div>
        )}
      </main>

      <footer className="mt-6 text-xs text-gray-500">Local-only storage (localStorage). Works offline and designed for reliability.</footer>
    </div>
  );
}

function SubtaskList({ task, addSubtask, toggleSubtask, removeSubtask }) {
  const [text, setText] = useState("");
  return (
    <div>
      <div className="flex gap-2 mb-2">
        <input value={text} onChange={(e) => setText(e.target.value)} className="flex-1 p-1 border rounded text-sm" placeholder="Add subtask" />
        <button onClick={() => { if (text.trim()) { addSubtask(task.id, text.trim()); setText(""); } }} className="p-1 border rounded text-sm">Add</button>
      </div>
      <ul className="space-y-1">
        {task.subtasks.map((st) => (
          <li key={st.id} className="flex items-center gap-2 text-sm">
            <input type="checkbox" checked={st.done} onChange={() => toggleSubtask(task.id, st.id)} />
            <span className={st.done ? 'line-through text-gray-500' : ''}>{st.title}</span>
            <button onClick={() => removeSubtask(task.id, st.id)} className="ml-auto p-1 border rounded text-xs">Remove</button>
          </li>
        ))}
        {task.subtasks.length === 0 && <li className="text-xs text-gray-400">No subtasks</li>}
      </ul>
    </div>
  );
}

</script>
</body>
</html>
